import { CastEvent } from '@cenk1cenk2/react-template-components'
import { projectDetails } from '@interfaces/project.constants'
import clsx from 'clsx'
import { debounce } from 'lodash'
import React, { Component, createContext, Fragment, useEffect } from 'react'
import styled, { css, useTheme } from 'styled-components'

import { animations as DrawerAnimations, DrawerNavigation } from './drawer-navigation'
import { Header } from './header'
import { Action, DashboardTemplateActions, DashboardTemplateNavStates, DashboardTemplateNavTypes, DashboardTemplateProps, State } from './index.interface'

export const DashboardTemplate: React.FC<DashboardTemplateProps> = () => {
  useEffect((effect) => {})
}

const handleResize = (e: Partial<Event>) => {
  const event = e as CastEvent<Window>
  const theme = useTheme()
  if (event.target.innerWidth < theme.breakpoints.values.md) {
    // set navigation type to menu type for smaller screens
    this.state.write({ navigation: { type: DashboardTemplateNavTypes.menu } })

    // when screen gets resized to small collapse the navigation
    this.state.dispatch({ type: DashboardTemplateActions['navigation:close'] })
  } else {
    // set navigation type to prop type when resized to a larger screen
    if (this.state.navigation.type !== this.props.navigation.type) {
      await this.state.write({ navigation: { type: this.props.navigation.type } })
    }

    // if intended type is menu, open it, else close it
    if (this.state.navigation.type === DashboardTemplateNavTypes.menu) {
      // when screen gets resized back expand the navigation
      this.state.dispatch({ type: DashboardTemplateActions['navigation:open'] })
    } else {
      this.state.dispatch({ type: DashboardTemplateActions['navigation:close'] })
    }
  }
}

const watchResize = debounce(handleResize.bind(this), 100, { leading: true })

export class Template extends Component<DashboardTemplateProps, Partial<State>> {
  public reducer (state: Partial<State>, action: Action) {
    if (action.type === DashboardTemplateActions['navigation:close']) {
      // navigation close action
      state = { navigation: { state: DashboardTemplateNavStates.close } }
    } else if (action.type === DashboardTemplateActions['navigation:open']) {
      // set state
      state = { navigation: { state: DashboardTemplateNavStates.open } }
    } else if (action.type === DashboardTemplateActions['navigation:toggle']) {
      if ([ DashboardTemplateNavStates.overlay, DashboardTemplateNavStates.open, DashboardTemplateNavStates.collapse ].includes(this.state.navigation.state)) {
        state = { navigation: { state: DashboardTemplateNavStates.close } }
      } else {
        state = { navigation: { state: DashboardTemplateNavStates.open } }
      }
    } else if (action.type === DashboardTemplateActions['navigation:mouseEnter']) {
      state = { navigation: { state: DashboardTemplateNavStates.open, mouse: true } }
    } else if (action.type === DashboardTemplateActions['navigation:mouseLeave']) {
      state = { navigation: { mouse: false } }
    }

    return state
  }

  public componentDidMount () {
    // set easier logical operations
    this.state.write({
      navigation: { type: this.props.navigation.type },
      narrow: this.props.narrow,
      header: this.props.header
    })
    this.state.write({ narrow: this.props.narrow })

    // set cross modes
    if (this.props.navigation.type === DashboardTemplateNavTypes.menu) {
      this.state.write({ narrow: false, header: { transperent: false } })
    }

    // add global listeners
    if (typeof window !== 'undefined') {
      window.addEventListener('resize', this.watchResize)
    }

    // set initial state for the render
    this.handleResize({ target: window })
  }

  public componentWillUnmount () {
    if (typeof window !== 'undefined') {
      window.removeEventListener('scroll', this.watchResize)
    }
  }

  public componentDidUpdate () {
    // check if window is collapsable or large enought to show the navigation bar
    if (this.state.navigation.state === DashboardTemplateNavStates.open) {
      let navigation: DashboardTemplateNavStates
      // decide on state, css makes it laggy
      if (this.props.navigation.collapsable && !this.state.navigation.mouse) {
        navigation = window.innerWidth > this.props.theme.breakpoints.values.md ? DashboardTemplateNavStates.collapse : DashboardTemplateNavStates.overlay
      } else {
        navigation = window.innerWidth > this.props.theme.breakpoints.values.md ? DashboardTemplateNavStates.open : DashboardTemplateNavStates.overlay
      }

      // set state
      if (this.state.navigation.state !== navigation) {
        this.state.write({ navigation: { state: navigation } })
      }
    }
  }

  public render () {
    return (
      <Fragment>
        <Provider value={this.state}>
          <Header transperent={this.state.header?.transperent} narrow={this.state.narrow} project={this.props.project} items={this.props.items} />
          <DrawerNavigation collapsable={this.props.navigation.collapsable} items={this.props.items} />
          <Main className={clsx(this.state.navigation.state, { narrow: this.state.narrow })}>{this.props.children}</Main>
        </Provider>
      </Fragment>
    )
  }

  private handleResize
}

const Main = styled.div(
  ({ theme }) => css`
    position: absolute;
    top: ${theme.template.header.headerSizeMin};
    padding-top: calc(${theme.template.header.headerSizeMin} * 0.1);
    ${DrawerAnimations('collapse', 'left')}

    &.open {
      left: ${theme.template.navigation.width};
    }

    &.collapse {
      left: ${theme.template.navigation.collapseWidth};
    }

    &.close {
      left: 0;
    }

    padding: ${theme.spacing(1)}px;

    ${theme.breakpoints.up('lg')} {
      &.narrow {
        padding-left: calc((100% - ${theme.breakpoints.values.lg}px) / 2);
        padding-right: calc((100% - ${theme.breakpoints.values.lg}px) / 2);
      }
    }
  `
)
